---
title: 'Find What Commit Introduced a Bug With Git Bisect'
publishedAt: '2022-01-07'
summary: 'TODO'
image: '/static/images/find-what-commit-introduced-a-bug-with-git-bisect/banner.png'
---

As developers, we often have to track down bugs and sometimes, they could be quite tedious to track down, especially within big codebases.

**How could we be more effective in finding the cause and fixing them?**

Well, there are a lot of effective tools these days, but we often forget how powerful git is. In this blog post, we will cover how to use `git bisect` to simplify our bug tracking sessions and how to automate this with tests.

## First things to do with a bug

One of the first thing I do when I need to tackle a bug is to understand what's going—obviously—and how to reproduce it. Then, write tests to assert expected behaviors.

By default, we often try to fix it first, then later we write a test to prevent further regressions. But what if we could leverage those tests to help us fix them in the first place?

Writing tests is super helpful, even early. This is especially true in the open source community, even if you don't know how to properly fix a bug, sending a pull request with tests will be a great help. Of course, they will be failing at first but they will become an excellent indicator to know when everything is working as expected and someone else could easily pick it up from there.

From there, how do we find how the bug was introduced? Let's say we don't have a stacktrace and we don't have any knowledge of the codebase. Where do we start? That's exactly where `git bisect` comes in.

## Preamble

As an example for this blog post, we'll refer to the following workshop: [github:charpeni/git-bisect-workshop](https://github.com/charpeni/git-bisect-workshop).

It's a small JavaScript library that does two simple math operations: sum and multiplication.

```javascript
import { sum, multiply } from './math';

console.log(sum(1, 2));
console.log(multiply(3, 4);
```

Unfortunately, the latest version of the library has a bug that causes the multiplication operation to return the wrong result. We know it was working fine previously, but we don't know when the bug was introduced or where to fix it.

If we want to write a test asserting the behavior of `multiply`, we could write the following test:

> ⚠️ Be careful to not commit the test yet, otherwise it won't be available on previous commits during a bisecting session.

```javascript
const { multiply } = require('./math');

describe('multiply', () => {
  it('the sum of 3 and 4 should equal 12', () => {
    expect(multiply(3, 4)).toBe(12);
  });
});
```

## Bisecting

In the past, I used to dig through the git history to understand what happened. But that's not always the best way to go and it could be quite tedious to manually checkout every commit to check if the bug is still there.

Git offers a better alternative: a command named `bisect` that uses binary search to find the commit that introduced a bug.

You specify the last good commit you know and a bad commit (the one with the bug, usually your current commit), then the command will do a binary search through all the in-between commits to ask you if the selected commit has the bug or not (if the commit is either bad or good). We will cover how to automate this later.

> ℹ️ The following content is coming and executed from the workshop repository mentioned above.

From the following git history, we know that the library used to work at least on the second commit (`Initial setup`) but something broke in-between the first commit and the last one.

TODO: Image of git history

So, we can find the commit that introduced the bug by starting a bisect session:

```bash
git bisect start
git bisect bad # this will select the current commit as the bad commit
git bisect good 52095727dd1afc8517cc9dda06568ae21f9b5850 # this is telling git that our second commit (Initial setup) is a good commit
```

Then, the bisecting session begin.

TODO: Image of a git bisect session start and bad. First

What happened here is that the binary search split commits in two parts from the good one to the bad one and it checkout the middle commit.

TODO: How to test a commit, either manual steps or tests

Then, we need to test this comment to check if whether this is a good or a bad commit. We could test it manually, or even better if we reuse our previous test. To do so, we need to copy the test above and paste it into the workshop repository as `test.spec.js`. If this was an application, we would have to either start the application and test it manually or write an integration / E2E test.

Then we can run the test with `yarn test` and assert if the test are passing or not.

In this case, it was failing, so we marked it as a bad commit, so we can continue the bisecting session by splitting another series of commits.

TODO: Image of a git bisect session

TODO: Output when `git bisect` finds the commit that introduced the bug

## Automation

TODO
